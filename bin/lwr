#!/usr/bin/env python

# live-wrapper - Wrapper for vmdebootstrap for creating live images
# (C) Iain R. Learmonth 2015 <irl@debian.org>
# See COPYING for terms of usage, modification and redistribution.
#
# bin/lwr - Live Wrapper (Application)

"""
This script is the main script for the live-wrapper application. It is
intended to be run from the command line.

See live-wrapper(8) for more information.
"""

# pylint: disable=wrong-import-order,missing-docstring,superfluous-parens

import sys
import os
import cliapp
import logging
import pycurl
import tempfile
from shutil import rmtree
from tarfile import TarFile
from lwr.vm import VMDebootstrap
from lwr.isolinux import install_isolinux, update_isolinux
from lwr.disk import install_disk_info
from lwr.grub import install_grub, update_grub
from lwr.xorriso import Xorriso
from lwr.apt_udeb import AptUdebDownloader

__version__ = '0.4'

# FIXME: needs to be a setting to allow for local full mirrors
# DI_BASE = 'http://ftp.debian.org/debian/dists/stretch/main/'
DI_BASE = 'http://localhost/mirror/debian/dists/stretch/main/'
KERNEL = 'vmlinuz'
RAMDISK = 'initrd.gz'
# FIXME: needs to allow for architecture setting
DI_KERNEL = (DI_BASE + 'installer-amd64/current/images/cdrom/' + KERNEL)
DI_RAMDISK = (DI_BASE + 'installer-amd64/current/images/cdrom/' + RAMDISK)
# Not used yet but may be good to have
# DI_KERNEL_GTK = (DI_BASE + 'installer-amd64/current/images/cdrom/gtk/' + KERNEL)
# DI_RAMDISK_GTK = (DI_BASE + 'installer-amd64/current/images/cdrom/gtk/' + RAMDISK)

DI_HELPERS = (
    DI_BASE + 'installer-amd64/current/images/cdrom/debian-cd_info.tar.gz')
# DI_HELPERS_GTK = (
#     DI_BASE + 'installer-amd64/current/images/cdrom/gtk/debian-cd_info.tar.gz')


def fetch_di_helpers():
    logging.info("Downloading helper files from debian-installer team...")
    try:
        cdhelp = tempfile.mkdtemp()
        os.makedirs(os.path.join(cdhelp, 'd-i'))
        kernel_path = os.path.join(cdhelp, 'd-i', KERNEL)
        ramdisk_path = os.path.join(cdhelp, 'd-i', RAMDISK)
        # python3 only
        if sys.version_info > (3, 0):
            ditar = tempfile.mkstemp()
            with ditar[0] as info:
                curl = pycurl.Curl()
                curl.setopt(curl.URL, DI_HELPERS)
                curl.setopt(curl.WRITEDATA, info)
                curl.perform()
                curl.close()
            info = TarFile.open(ditar[1], 'r:gz')
            info.extractall(path=cdhelp)
            info.close()
            os.remove(ditar[1])
        # python 2
        else:
            ditar = tempfile.NamedTemporaryFile(delete=False)  # pylint: disable=redefined-variable-type
            curl = pycurl.Curl()
            curl.setopt(curl.URL, DI_HELPERS)
            curl.setopt(curl.WRITEDATA, ditar)
            curl.perform()
            curl.close()
            ditar.close()
            info = TarFile.open(ditar.name, 'r:gz')
            info.extractall(path=cdhelp)
            info.close()
            os.remove(ditar.name)
        with open(kernel_path, 'w') as kernel:
            curl = pycurl.Curl()
            curl.setopt(curl.URL, DI_KERNEL)
            curl.setopt(curl.WRITEDATA, kernel)
            curl.perform()
            curl.close()
        with open(ramdisk_path, 'w') as ramdisk:
            curl = pycurl.Curl()
            curl.setopt(curl.URL, DI_RAMDISK)
            curl.setopt(curl.WRITEDATA, ramdisk)
            curl.perform()
            curl.close()
        return (cdhelp, kernel_path, ramdisk_path)
    except pycurl.error:
        logging.error("Failed to fetch the debian-installer helper files! " +
                      "Cannot continue!")
        sys.exit(1)


class LiveWrapper(cliapp.Application):

    # Instance variables
    cdroot = None  # The path to the chroot the CD is being built in
    cdhelp = None  # The path to the debian-installer team helpers
    di_kernel = None
    di_ramdisk = None
    gtk_di_kernel = None
    gtk_di_ramdisk = None

    def add_settings(self):
        self.settings.string(
            ['o', 'image_output'], 'Location for built image',
            metavar='/PATH/TO/FILE.ISO',
            default='live.iso', group='Base Settings')
        self.settings.string(
            ['d', 'distribution'], 'Debian release to use (default: %default)',
            metavar='NAME',
            default='stable', group='Base Settings')
        self.settings.string(
            ['m', 'mirror'], 'Mirror to use for image creation',
            metavar='MIRROR',
            group='Base Settings')
        self.settings.string(
            ['t', 'tasks'], 'Task packages to install',
            metavar='"task-TASK1 task-TASK2 ..."',
            group='Packages')
        self.settings.string(
            ['e', 'extra'], 'Extra packages to install',
            metavar='"PKG1 PKG2 ..."',
            group='Packages')
        self.settings.boolean(
            ['isolinux'], 'Add isolinux bootloader to the image '
            '(default: %default)', default=True, group="Bootloaders")
        self.settings.boolean(
            ['grub'], 'Add GRUB bootloader to the image (for EFI support) '
            '(default: %default)', default=True, group="Bootloaders")
        self.settings.boolean(
            ['grub-loopback-only'], 'Only install the loopback.cfg GRUB '
            'configuration (for loopback support) (overrides --grub) '
            '(default: %default)', default=False, group="Bootloaders")

    def process_args(self, args):
        if os.path.exists(self.settings['image_output']):
            raise cliapp.AppException("Image '%s' already exists" % self.settings['image_output'])
        if not self.settings['isolinux'] and not self.settings['grub']:
            raise cliapp.AppException("You must enable at least one bootloader!")
        if self.settings['grub'] and self.settings['grub-loopback-only']:
            self.settings['grub'] = False
        if os.geteuid() != 0:
            sys.exit("You need to have root privileges to run this script.")
        self.start_ops()

    def start_ops(self):  # pylint: disable=too-many-statements
        """
        This function creates the live image using the settings determined by
        the arguments passed on the command line.

        .. note::
            This function is called by process_args() once all the arguments
            have been validated.
        """

        print("Creating work directory...")
        logging.info("Creating work directory...")

        # Create work directory
        self.cdroot = tempfile.mkdtemp()

        logging.debug("Setting environment variables for customise hook...")

        # Make options available to customise hook in vmdebootstrap
        os.environ['LWR_TASK_PACKAGES'] = self.settings['tasks']
        os.environ['LWR_EXTRA_PACKAGES'] = self.settings['extra']
        if self.settings['mirror'] == "":
            os.environ['MIRROR'] = self.settings['mirror']

        logging.info("Running vmdebootstrap...")
        print("Running vmdebootstrap...")

        # Run vmdebootstrap, putting files in /live/
        vm = VMDebootstrap(self.settings['distribution'],
                           self.settings['mirror'], self.cdroot)
        vm.run()

        # Fetch D-I helper archive if needed
        if self.settings['grub']:
            print("Fetching Debian Installer helpers")
            helpers = fetch_di_helpers()
            self.cdhelp = helpers[0]
            self.di_kernel = helpers[1]
            self.di_ramdisk = helpers[2]

        # Download the udebs
        print("Downloading udebs for Debian Installer...")  # FIXME: self.message()
        logging.info("Downloading udebs for Debian Installer...")
        # FIXME: get exclude_list from user
        exclude_list = []
        # FIXME: may need a change to the download location
        di_root = os.path.join(self.cdroot, 'd-i')
        os.makedirs(di_root)
        apt_udeb = AptUdebDownloader(destdir=di_root)
        apt_udeb.mirror = self.settings['mirror']
        apt_udeb.architecture = 'amd64'  # FIXME: self.settings
        apt_udeb.suite = self.settings['distribution']
        print("Updating cache...")  # FIXME: self.message()
        logging.debug("Updating cache...")
        apt_udeb.prepare_apt()
        # FIXME: add support for a custom apt source on top.

        # download all udebs in the suite, except exclude_list
        apt_udeb.download_udebs(exclude_list)
        apt_udeb.clean_up_apt()
        print("... completed udeb downloads", self.cdroot)
        logging.info("... completed udeb downloads")

        # Install isolinux if selected
        if self.settings['isolinux']:
            logging.info("Performing isolinux installation...")
            install_isolinux(self.cdroot)
            update_isolinux(self.cdroot, self.di_kernel, self.di_ramdisk)

        # Install GRUB if selected
        if self.settings['grub'] or self.settings['grub-loopback-only']:
            logging.info("Performing GRUB installation...")
            install_grub(self.cdroot, self.cdhelp)
            update_grub(self.cdroot, self.di_kernel, self.di_ramdisk)

        # Install .disk information
        logging.info("Installing the disk metadata (badly)...")
        install_disk_info()

        # Create ISO image
        logging.info("Creating the ISO image with Xorriso...")
        xorriso = Xorriso(self.settings['image_output'],
                          isolinux=self.settings['isolinux'],
                          grub=self.settings['grub'])
        xorriso.build_args(self.cdroot)
        xorriso.build_image()

        # Remove the temporary directories
        logging.info("Removing temporary work directories...")
        if self.cdhelp is not None:
            rmtree(self.cdhelp)
        rmtree(self.cdroot)

if __name__ == "__main__":
    LiveWrapper(version=__version__).run()
